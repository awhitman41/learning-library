# Invoking the Deployed Function

## Introduction

Now that your Oracle Function has been successfully deployed, you need to test it. You can easily test the function by submitting a few requests using the OCI Python SDK directly in your notebook. If you prefer to use Cloud Shell, you can also [invoke your model](https://fnproject.io/tutorials/python/intro/%22%20%5Cl%20%22InvokeyourDeployedFunction) directly with the fn CLI tool. 

### Objectives

In this lab, you will:
* Test the Function
* Get the invoke_endpoint of the Function

## Task 1: Test the Function

Import the libraries that you need, most notably oci and the functions client. 

```python
import matplotlib.pyplot as plt
import datetime
import gzip 

import oci 
from oci import pagination
import oci.functions as functions
from oci.functions import FunctionsInvokeClient
```

I use resource principals in my notebook session to authenticate against Oracle Functions. Instantiate a FunctionsManagementClient object using the resource principals signer object, allowing your notebook session to call functions without using your personal config and key files. The FunctionsManagementClient object allows you to list all applications and functions in my compartment.

```python
# Lets first get the resource principals signer object: 
rps = oci.auth.signers.get_resource_principals_signer()

# Instantiate a FunctionsManagementClient object using the resource principals signer: 
fn_management_client = FunctionsManagementClient(config={}, signer=rps)
```

Fill in the compartment application OCID and application and function names: 

```python
# Your application compartment OCID: 
compartment_id = f"<your-application-compartment-OCID>"
# Your application name: 
app_name = f"<your-application-name>"
# Your Function name: 
fn_name = f"<your-function-name>"
```

## Task 2: Get the invoke_endpoint of the Function

Next, we need to get the invoke _ endpoint of the function. Find the function OCID. If you want to stay in the notebook session environment, you can find your function OCID by listing the applications in the compartment. You can inspect the results by calling app _ results.data. 

Then, identify the application and extract the OCID of the application by accessing the .id attribute of each entry in the list. Because each application is a collection of functions, the same logic applies at the application level. List the functions inside the application and find the relevant one.

```python
app_result = pagination.list_call_get_all_results(
        fn_management_client.list_applications,
        compartment_id,
        display_name=app_name
    )
# app_result.data
# OCID of the first application in the list: 
# app_result.data[0].id

fn_result = pagination.list_call_get_all_results(
        fn_management_client.list_functions,
        app_result.data[0].id,
        display_name=fn_name
    )
# fn_result.data
# OCID of the first Function in the list:
# fn_result.data[0].id
```
I have multiple functions in my application, but the relevant one is the first in my list ([0]). Extract the .invoke_endpoint attribute of that function, and pass it to the FunctionsInvokeClient object, which allows you to invoke the function.

```python
invoke_client = FunctionsInvokeClient({}, signer=rps, service_endpoint=fn_result.data[0].invoke_endpoint)
```

The client object that I instantiated (invoke _ client) has an invoke_function() method that allows me to submit requests to my function. It takes the function OCID as the required parameter. 

I also cut the training data frame into blocks of five rows and passed them as my JSON payload to my function endpoint. You can execute this cell a few times to simulate calls made to your function. You can change the number of rows you pass to the model in each call. 

The first time you call your function, it can take much more time to get a response back (>30 sec). That’s the cold start problem. 

For each call you made to your functions, the output of the loggers you created in func.py is collected and stored in log files on object storage.

```python
%%time 

# calling my model 10 times. Each time I pass five rows from my training datasets that I converted to a JSON payload (content-type: application/json) 
for x in range(10): 
    resp = invoke_client.invoke_function(fn_result.data[0].id, 
                                         invoke_function_body=json.dumps({'input':train[5*x:5*(x+1)].to_json()}))
    print(resp.data.text)
```

Congratulations! You have made it to the end! You can use the logs generated by your Function to monitor the performance of you model. 

## Learn More

* [Blog Post- Deploying a Machine Learning Model with Oracle Functions](https://blogs.oracle.com/ai-and-datascience/post/deploying-a-machine-learning-model-with-oracle-functions)
* [Other Related Blog Posts](https://blogs.oracle.com/ai-and-datascience/authors/Blog-Author/COREA7667DA212B34765B4DB91B94737F00E/jean-rene-gauthier)

## Acknowledgements
* **Author** - Jean-Rene Gauthier, Sr Principal Product Data Scientist
* **Contributors** -  Samuel Cacela, Cloud Engineer & Aaron Whitman, Cloud Engineer